Name: Levi McKenzie-Kirkbright
Student ID: 583 703

The MOPA assignment contained complex logic and required difficult reasoning about concurrency and mutex when many processes were accessing a single data structure (the foyer). Specifically, there are five processes accessing the foyer: producer, consumer, security guard, and the two guides. At one point I had written so much spaghetti code in the security guard and the foyer that I was completely confused about what was causing the deadlocks and loops. I had to effectively rewrite both classes, trying my best to keep the logic very clear and the code as concise as possible. Aiming for a simpler conceptual disaggregation of the relationship between the foyer and the guard, and the foyer and the two guides made the code a lot simpler. Once the concept behind the code was simpler, it was easier to reason about, implement and debug.

The foyer had much more complex logic than the rooms. The guard needs to make sure the Foyer is empty before escorting a new arriving group through the security check into the Foyer. However, this presented a tricky problem: if there is a group in the Foyer, is that group an old group or is it a new group?
Old groups had completed their trip through the museum. They are waiting for the security guard to do the security check and escort them out of the museum. 
New group: they have not yet started their trip through the museum and are waiting for the first guide to escort them from the Foyer into Room 0.
The security guard should wait with the new arriving group if and only if the group in the Foyer is waiting to enter Room 0 (i.e. they are a new group).
If the group in the Foyer is waiting to depart the museum (i.e. they are an old group that came from Room (N-1) and are waiting to go through the security check again) then the Security Guard must leave the new group outside the security check, go inside, escort the group in the Foyer through the Security check. 

Debugging concurrent programs is extremely difficult and time-consuming because of the nondeterminism of when and in what order bugs arise during execution. The same bug may not arise on every run. Often there is a pattern leading up to an issue, such as a deadlock, but there is no error output so the programmer needs to decipher that pattern to try to deduce what is causing the deadlock (or loop) in the underlying code. 

Uncertainty about correctness means that the programmer needs to execute the program multiple times while modifying parameters, especially the number of rooms. The longer the process runs without starvation or deadlock, the more certainty. However, this “empirical” approach is not a guarantee of correctness because an incorrect program may still run correctly for a long time by pure chance. The programmer needs to let the code run sufficiently long to be confident that the bug is no longer there, and run it multiple times to allow for variability in the initial execution order of threads.
